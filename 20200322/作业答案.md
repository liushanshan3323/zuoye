###1
obj{function()}  window
###2
undefined 'language'
###3
'window'
###4
'24'
###5
'12'
###6
22 23 65,30
###7
不能实现效果
现在的效果是不论点击哪个输出的都是5
第一种修改方法：把循环里的var改为let，因为利用ES6中块上下文（作用域）的概念，每一轮循环都会形成一个私有的上下文，里面记录了私有变量的i，i的值分别是每一轮循环的结果 0/1/2...
第二种修改方法： 利用闭包的保存作用：形成一个不被释放的私有上下文
第三种修改方法：自定义属性来存储每一轮循环完i的值
###8
闭包就是函数在执行时形成一个不出栈，不被销毁，可以存储我们要用到的数据的私有上下文

好处：可以保护我们需要用到的数据不被销毁，可以保存我们需要用到数据

缺点：如果形成很多闭包，就相当于形成很多不出栈的私有上下文，此时会占用大不部分内存，导致运行的速度变慢
###9
1.var存在变量提升  而let不存在
2.let是不允许重复声明的：在当前上下文中，不管用什么方式，只要声明了这个变量，都不能在基于let重复声明了（而var允许重复声明，浏览器本身只识别一次，但是不会报错）
3.是否重新声明，并不是在代码执行阶段检测的，而是在词法解析阶段检测的（词法解析阶段类似于变量提升，在代码还没有执行之前，就发生了，一旦发现有词法错误 SyntaxError ，当前代码都不会再执行了）
4.在全局上下文中，用var声明的变量即是全局变量，也相当于给GO(window)设置了一个属性，而且两者建立映射机制；但是用let声明的变量仅仅是全局变量，和GO没关系；
5.浏览器有一个BUG（暂时性死区）：基于typeof检测一个没有被声明过的变量，并不会报错，结果是"undefined";如果这个变量在后面会用let声明，则前面再基于typeof检测就会报错：不能在声明之前使用
6.大括号中（例如：判断和循环）出现let，在执行时会把当前大括号包起来的部分形成一个独立的私有上下文，基于let创建的变量是当前块级作用域域中的私有变量
###10
```
   for (var i = 0; i < 10; i++) {
            setTimeout(() => {
               return function(){
                   console.log(i);
               } 
            }, 1000);
        }
 ```
###11
没太懂


